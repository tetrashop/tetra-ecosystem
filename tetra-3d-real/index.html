<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>ØªØªØ±Ø§ 3D - Ø³ÛŒØ³ØªÙ… ÙˆØ§Ù‚Ø¹ÛŒ ØªØ¨Ø¯ÛŒÙ„ 2D Ø¨Ù‡ 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
</head>
<body>
    <div id="app">
        <h1>ðŸŽ¯ Ø³ÛŒØ³ØªÙ… ÙˆØ§Ù‚Ø¹ÛŒ ØªØ¨Ø¯ÛŒÙ„ 2D Ø¨Ù‡ 3D</h1>
        
        <div class="upload-section">
            <input type="file" id="real-image-input" accept="image/*">
            <button onclick="startRealConversion()">ØªØ¨Ø¯ÛŒÙ„ ÙˆØ§Ù‚Ø¹ÛŒ</button>
        </div>

        <div id="real-3d-viewer"></div>
        
        <div class="download-section">
            <button onclick="downloadRealModel('glb')">Ø¯Ø§Ù†Ù„ÙˆØ¯ GLB ÙˆØ§Ù‚Ø¹ÛŒ</button>
            <button onclick="downloadRealModel('obj')">Ø¯Ø§Ù†Ù„ÙˆØ¯ OBJ ÙˆØ§Ù‚Ø¹ÛŒ</button>
        </div>
    </div>

    <script>
        class RealTetraConverter {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer();
                this.currentModel = null;
                
                this.init3DViewer();
            }

            init3DViewer() {
                this.renderer.setSize(800, 600);
                document.getElementById('real-3d-viewer').appendChild(this.renderer.domElement);
                
                // Ù†ÙˆØ±Ù¾Ø±Ø¯Ø§Ø²ÛŒ
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(1, 1, 1);
                this.scene.add(light);
                
                this.camera.position.z = 5;
            }

            async convertImageToReal3D(imageFile) {
                console.log('Ø´Ø±ÙˆØ¹ ØªØ¨Ø¯ÛŒÙ„ ÙˆØ§Ù‚Ø¹ÛŒ...');
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ø¹Ù…Ù‚ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø±ÙˆØ´Ù†Ø§ÛŒÛŒ Ù¾ÛŒÚ©Ø³Ù„â€ŒÙ‡Ø§
                const depthGeometry = await this.createDepthBasedGeometry(imageFile);
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø¯Ù„ Ø³Ù‡ Ø¨Ø¹Ø¯ÛŒ
                this.create3DModel(depthGeometry, imageFile);
                
                return depthGeometry;
            }

            async createDepthBasedGeometry(imageFile) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const geometry = this.generate3DGeometryFromImageData(imageData);
                        
                        resolve(geometry);
                    };
                    img.src = URL.createObjectURL(imageFile);
                });
            }

            generate3DGeometryFromImageData(imageData) {
                const width = imageData.width;
                const height = imageData.height;
                const data = imageData.data;

                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                const colors = [];

                // Ú©Ø§Ù‡Ø´ Ø±Ø²ÙˆÙ„ÙˆØ´Ù† Ø¨Ø±Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø¨Ù‡ØªØ±
                const step = 2;
                const scaledWidth = Math.floor(width / step);
                const scaledHeight = Math.floor(height / step);

                // Ø§ÛŒØ¬Ø§Ø¯ ÙˆØ±ØªÚ©Ø³â€ŒÙ‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø±ÙˆØ´Ù†Ø§ÛŒÛŒ
                for (let y = 0; y < scaledHeight; y++) {
                    for (let x = 0; x < scaledWidth; x++) {
                        const pixelX = x * step;
                        const pixelY = y * step;
                        const index = (pixelY * width + pixelX) * 4;

                        const r = data[index] / 255;
                        const g = data[index + 1] / 255;
                        const b = data[index + 2] / 255;
                        
                        // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø±ÙˆØ´Ù†Ø§ÛŒÛŒ Ø¨Ø±Ø§ÛŒ Ø¹Ù…Ù‚
                        const brightness = (r + g + b) / 3;
                        const depth = brightness * 5; // Ø¹Ù…Ù‚ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø±ÙˆØ´Ù†Ø§ÛŒÛŒ

                        vertices.push(
                            (x - scaledWidth/2) * 0.1,
                            (scaledHeight/2 - y) * 0.1,
                            depth
                        );

                        colors.push(r, g, b);
                    }
                }

                // Ø§ÛŒØ¬Ø§Ø¯ ØµÙØ­Ø§Øª
                for (let y = 0; y < scaledHeight - 1; y++) {
                    for (let x = 0; x < scaledWidth - 1; x++) {
                        const a = y * scaledWidth + x;
                        const b = a + 1;
                        const c = a + scaledWidth;
                        const d = c + 1;

                        indices.push(a, b, c);
                        indices.push(b, d, c);
                    }
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                return geometry;
            }

            create3DModel(geometry, imageFile) {
                // Ø­Ø°Ù Ù…Ø¯Ù„ Ù‚Ø¨Ù„ÛŒ
                if (this.currentModel) {
                    this.scene.remove(this.currentModel);
                }

                // Ø§ÛŒØ¬Ø§Ø¯ Ù…ØªØ±ÛŒØ§Ù„ Ø¨Ø§ ØªÚ©Ø³Ú†Ø± ØªØµÙˆÛŒØ±
                const texture = new THREE.TextureLoader().load(URL.createObjectURL(imageFile));
                const material = new THREE.MeshStandardMaterial({ 
                    map: texture,
                    vertexColors: true 
                });

                this.currentModel = new THREE.Mesh(geometry, material);
                this.scene.add(this.currentModel);

                // Ø§Ù†ÛŒÙ…ÛŒØ´Ù†
                this.animate();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.currentModel) {
                    this.currentModel.rotation.y += 0.01;
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            async exportToGLB() {
                return new Promise((resolve) => {
                    const exporter = new GLTFExporter();
                    exporter.parse(this.scene, (glb) => {
                        const blob = new Blob([glb], { type: 'model/gltf-binary' });
                        resolve(blob);
                    }, { binary: true });
                });
            }

            exportToOBJ() {
                let objString = '# Ù…Ø¯Ù„ 3D Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· ØªØªØ±Ø§\n';
                
                if (this.currentModel) {
                    const position = this.currentModel.geometry.attributes.position;
                    const indices = this.currentModel.geometry.index;

                    // ÙˆØ±ØªÚ©Ø³â€ŒÙ‡Ø§
                    for (let i = 0; i < position.count; i++) {
                        objString += `v ${position.getX(i)} ${position.getY(i)} ${position.getZ(i)}\n`;
                    }

                    // ØµÙØ­Ø§Øª
                    for (let i = 0; i < indices.count; i += 3) {
                        objString += `f ${indices.getX(i)+1} ${indices.getX(i+1)+1} ${indices.getX(i+2)+1}\n`;
                    }
                }

                return new Blob([objString], { type: 'text/plain' });
            }
        }

        // Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù…ÙˆÙ†Ù‡ Ø§Ø² Ù…Ø¨Ø¯Ù„ ÙˆØ§Ù‚Ø¹ÛŒ
        const realConverter = new RealTetraConverter();

        async function startRealConversion() {
            const fileInput = document.getElementById('real-image-input');
            if (!fileInput.files[0]) {
                alert('Ù„Ø·ÙØ§Ù‹ ÛŒÚ© ØªØµÙˆÛŒØ± Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯');
                return;
            }

            try {
                const file = fileInput.files[0];
                await realConverter.convertImageToReal3D(file);
                alert('âœ… ØªØ¨Ø¯ÛŒÙ„ ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯! Ù…Ø¯Ù„ 3D Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡ Ø±Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯.');
            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± ØªØ¨Ø¯ÛŒÙ„:', error);
                alert('âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ¨Ø¯ÛŒÙ„ ØªØµÙˆÛŒØ±. Ù„Ø·ÙØ§Ù‹ ØªØµÙˆÛŒØ± Ø¯ÛŒÚ¯Ø±ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');
            }
        }

        async function downloadRealModel(format) {
            if (!realConverter.currentModel) {
                alert('Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© ØªØµÙˆÛŒØ± ØªØ¨Ø¯ÛŒÙ„ Ú©Ù†ÛŒØ¯');
                return;
            }

            try {
                let blob, filename;
                
                if (format === 'glb') {
                    blob = await realConverter.exportToGLB();
                    filename = 'model-3d.glb';
                } else if (format === 'obj') {
                    blob = realConverter.exportToOBJ();
                    filename = 'model-3d.obj';
                }

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                
                alert(`âœ… Ù…Ø¯Ù„ Ø¨Ø§ ÙØ±Ù…Øª ${format.toUpperCase()} Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø´Ø¯`);
            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø§Ù†Ù„ÙˆØ¯:', error);
                alert('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ø¯Ø§Ù†Ù„ÙˆØ¯ÛŒ');
            }
        }
    </script>

    <style>
        body { font-family: Tahoma; direction: rtl; text-align: center; }
        #real-3d-viewer { margin: 20px auto; border: 2px solid #007bff; }
        button { padding: 10px 20px; margin: 10px; background: #007bff; color: white; border: none; cursor: pointer; }
    </style>
</body>
</html>
